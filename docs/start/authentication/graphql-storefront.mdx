# Authenticating requests to the GraphQL Storefront API

Authenticate GraphQL Storefront API requests using bearer tokens passed with the `Authorization` header. You can authenticate using two different kinds of tokens: [storefront tokens](#storefront-tokens) or [customer impersonation tokens](#customer-impersonation-tokens).

```http filename="Example request configuration" showLineNumbers copy
POST https://your_store.example.com/graphql
Authorization: Bearer {token}
Accept: application/json
Content-Type: application/json

{
  // request body
}
```

## Storefront tokens

Storefront tokens are most appropriate to use directly from the web browser. If you're creating a token for an application that will make server-to-server or proxied requests to the GraphQL Storefront API, or you work with customer data, use a [customer impersonation token](#customer-impersonation-tokens). If you only wish to query information from an anonymous shopper's perspective, use a storefront token.

### Storefront token security

Generally speaking, vanilla storefront tokens are not considered sensitive, and it is safe to expose them in web browsers. Storefront tokens can only expose information and actions that shoppers can access when they browse a storefront. 

It is possible to create a long-lived token that does not expire. For greater security, we recommend creating shorter-lived tokens and rotating them periodically.

For security reasons, GraphQL Storefront API tokens are scoped to particular [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) origins, so you must supply the origin or origins on which you intend to use the token. If you have more than two origins, you will need multiple tokens. If you do not supply any CORS origins, the API will reject requests originating from web browsers, although you can still use it in other contexts.

### Create a storefront token

You can create storefront tokens by API. On Stencil storefronts, you can also [access an autogenerated token](#using-auto-generated-tokens-on-stencil-storefronts) using in-page context.

Use the [Create a storefront token](/docs/rest-authentication/tokens#create-a-token) REST endpoint to create storefront bearer tokens. Add the [storefront API tokens creation scope](/docs/start/authentication/api-accounts#token-creation-scopes) to the [store-level or app-level API account](/docs/start/authentication/api-accounts) you use to generate tokens.

<Callout type="info">
  The channel ID for the default Stencil storefront is `1`. To learn more about channels, see [the channels section of the multi-storefront overview](/docs/storefront/multi-storefront#channels). For more about using the GraphQL Storefront API on custom channels, consult the GraphQL Storefront API overview's [FAQ section on alternate channels](/docs/storefront/graphql#i-want-to-run-requests-in-the-context-of-another-channel).
</Callout>

<Tabs items={['Request', 'Response']}>
<Tab>

```http filename="Example request: Create a storefront API token" showLineNumbers copy
POST https://api.bigcommerce.com/stores/{{STORE_HASH}}/v3/storefront/api-token
x-auth-token: {{access_token}}
accept: application/json
content-type: application/json

{
  "channel_ids": [1, 2, 3],            // array of integers (must be a valid channel IDs on the store)
  "expires_at": 1602288000,   // when the token will expire, as an integer unix timestamp (in seconds)
  "allowed_cors_origins": [   // array of origins (up to 2 origins per token)
    "https://example.com"
  ]
}
```
</Tab>
<Tab>

```json filename="Example response: Create a storefront API token" showLineNumbers copy
{
  "token": "...eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NiJ9...",
  "meta": {
    // ...
  }
}
```
</Tab>
</Tabs>

### Using auto-generated tokens on Stencil storefronts

On Stencil storefronts, you can access a token at render time and pass the token to client-side code using the `{{settings.storefront_api.token}}` Handlebars property. This auto-generated token has an expiry period of 24-48 hours and will rotate before expiration.

## Customer impersonation tokens

You can use customer impersonation tokens to authenticate requests to the GraphQL Storefront API in server-to-server and headless interactions. The API will reject any customer impersonation token-authenticated requests that originate from a web browser and are not proxied. Use these tokens in NextJS applications; NextJS proxies requests by default.

Customer impersonation token-authenticated requests can query store information for any customer by passing the customer ID using the `X-Bc-Customer-Id` header. Information that you request will be specific to the subject customer, including product pricing and availability, customer account details, and more.

It is not necessary to generate a new token for each customer ID. You may use a single token at any given time for your application, and specify a distinct customer ID for each set of requests.

Using a customer impersonation token does not automatically sign a customer in. For that, use the [customer login mutation](#signing-customers-in) or the [Customer Login API](/docs/rest-authentication/customer-login).

### Create a customer impersonation token

Add the [Storefront API customer impersonation tokens creation scope](/docs/start/authentication/api-accounts#token-creation-scopes) to the [store-level or app-level API account](/docs/start/authentication/api-accounts) you use when you [Create a customer impersonation token](/docs/rest-authentication/tokens/customer-impersonation-token). 

<Tabs items={['Request', 'Response']}>
<Tab>

```http filename="Example request: Create a customer impersonation token" showLineNumbers copy
POST https://api.bigcommerce.com/stores/{{STORE_HASH}}/v3/storefront/api-token-customer-impersonation
X-Auth-Token: {{access_token}}
Accept: application/json
Content-Type: application/json

{
  "channel_ids": [1, 2, 3] // array of integers (must be a valid channel IDs on the store)
  "expires_at": 1602288000 // when the token will expire, as an integer unix timestamp (in seconds)
}
```
</Tab>
<Tab>

```json filename="Example response: Create a customer impersonation token" showLineNumbers copy
{
  "data":
  {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
  },
  "meta": {}
}
```
</Tab>
</Tabs>

### Customer impersonation token security

Unlike storefront API tokens, customer impersonation tokens _are_ sensitive and should **never** be exposed publicly. Treat them with the same care as other application secrets, such as API account access tokens. 

If your token is compromised, you can use the [Revoke a token](/docs/rest-authentication/tokens#revoke-a-token) endpoint. Only use this in emergencies; do not revoke tokens unnecessarily. Instead, use a shorter expiration and allow them to expire naturally.

## Signing customers in

<Callout type="info">
A customer can only sign in on one device. When you run the customer login mutation for a session on a new device, the customer is automatically signed out of the previous session.
</Callout>

If you're using the GraphQL Storefront API from a browser, for example, on top of your Stencil storefront, you can use the login mutation to sign in to a customer account with an email address and a password. This will set a session cookie in the browser, which will authenticate the customer account on future requests.

This mutation is also useful for server-to-server or headless storefront applications that use a customer impersonation token. For example, you can use a sign in form to validate a customer's email address and password. When the mutation returns successfully, you can take the resulting customer ID and store it in a session to pass with the `X-Bc-Customer-Id` header.

As a security best practice, you should inject the email address and password using GraphQL query variables. This prevents the password from being exposed in the query itself. In the [GraphQL Storefront playground](/graphql-storefront/playground), you can set variables for requests.

![GraphQL Storefront playground query variables](https://storage.googleapis.com/bigcommerce-production-dev-center/images/Playground%20Login%20Mutation.png "GraphQL Storefront playground query variables")

<Callout type="warning">
  In the customer login mutation, the `result` field is deprecated. Instead, request customer object information.
</Callout>

<Tabs items={['HTTP', 'Mutation', 'Variables', 'Response']}>
  <Tab>

    ```http filename="Login mutation request" copy
      POST https://your_store.example.com/graphql
      Accept: application/json
      Content-Type: application/json
      Authorization: Bearer {token}
    ```

  </Tab>
  <Tab>

    ```graphql filename="Login mutation" showLineNumbers copy
      mutation Login($email: String!, $pass: String!) {
        login(email: $email, password: $pass) {
          customer {
            entityId
            firstName
            email
            taxExemptCategory
            storeCredit {
              currencyCode
              value
            }
            formFields {
              entityId
              name
            }
          }
        }
      }
    ```

  </Tab>
  <Tab>

    ```json filename="Login mutation variables" showLineNumbers copy
      {
        "email": "jane.doe@example.com",
        "pass": "xxxxxxxxxxxxxxxxx"
      }
    ```

  </Tab>
  <Tab>

    ```json filename="Login mutation response" showLineNumbers copy
      {
        "data": {
          "login": {
            "customer": {
              "entityId": 378,
              "firstName": "Jane",
              "email": "jane.doe@example.com",
              "customerGroupId": 7,
              "taxExemptCategory": "",
              "storeCredit": [
                {
                  "currencyCode": "USD",
                  "value": 0
                }
              ],
              "formFields": [
                {
                  "entityId": 26,
                  "name": "Birthday"
                }
              ]
            }
          }
        }
      }
    ```

  </Tab>
</Tabs>

## Signing customers out

You can use the logout mutation to sign out of a customer account. If you're using a vanilla storefront token, future requests in that shopper's session will be from the perspective of an anonymous shopper.

```graphql filename="Example query: logout mutation" showLineNumbers copy
mutation Logout {
  logout {
    result
  }
}
```

## Further reading

* [GraphQL Storefront API overview](/docs/storefront/graphql)
* [GraphQL Storefront API reference](/graphql-storefront/reference)
* [GraphQL Storefront playground](/graphql-storefront/playground)
* [Authentication and example requests: GraphQL Storefront API](/docs/start/authentication)
* [Guide to API accounts: OAuth scopes](/docs/start/authentication/api-accounts#token-creation-scopes)
* [Multi-storefront overview](/docs/storefront/multi-storefront)
* [CORS (Mozilla)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)

### Endpoints

* [Create a storefront token](/docs/rest-authentication/tokens#create-a-token)
* [Create a customer impersonation token](/docs/rest-authentication/tokens/customer-impersonation-token)
* [Revoke a token](/docs/rest-authentication/tokens#revoke-a-token)
* [Customer Login API](/docs/rest-authentication/customer-login)
