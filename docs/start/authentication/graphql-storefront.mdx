# Authenticating requests to the GraphQL Storefront API

Authenticate GraphQL Storefront API requests using bearer tokens passed with the `Authorization` header. You can authenticate using three different kinds of tokens: [storefront tokens](#storefront-tokens), [private tokens](#private-tokens), or [customer impersonation tokens](#customer-impersonation-tokens).

```http filename="Example request configuration" showLineNumbers copy
POST https://your_store.example.com/graphql
Authorization: Bearer {token}
Accept: application/json
Content-Type: application/json

{
  // request body
}
```

## Storefront tokens

Storefront tokens are designed for use directly from the web browser. They support CORS via `allowed_cors_origins` and are intended for browser-based applications. For server-to-server integrations, use [private tokens](#private-tokens) instead. If you need to work with customer data, use a [customer impersonation token](#customer-impersonation-tokens). If you only wish to query information from an anonymous shopper's perspective in a browser context, use a storefront token.

<Callout type="warning">
**Deprecation notice:** A deprecation date will be introduced soon. After this date, new storefront tokens created will not be usable statelessly in server-to-server contexts. Existing storefront tokens created before the deprecation date will continue to work in server-to-server contexts. We will contact merchants about migrating to private tokens. If you're planning a server-to-server integration, you should use [private tokens](#private-tokens) now.
</Callout>

### Storefront token security

Generally speaking, vanilla storefront tokens are not considered sensitive, and it is safe to expose them in web browsers. Storefront tokens can only expose information and actions that shoppers can access when they browse a storefront.

It is possible to create a long-lived token that does not expire. For greater security, we recommend creating shorter-lived tokens and rotating them periodically.

For security reasons, GraphQL Storefront API tokens are scoped to particular [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) origins, so you must supply the origin or origins on which you intend to use the token. If you have more than two origins, you will need multiple tokens.

### Create a storefront token

You can create storefront tokens by API. On Stencil storefronts, you can also [access an autogenerated token](#using-auto-generated-tokens-on-stencil-storefronts) using in-page context.

Use the [Create a storefront token](/docs/rest-authentication/tokens#create-a-token) REST endpoint to create storefront bearer tokens. Add the [storefront API tokens creation scope](/docs/start/authentication/api-accounts#token-creation-scopes) to the [store-level or app-level API account](/docs/start/authentication/api-accounts) you use to generate tokens. You can use a storefront bearer token to create a [customer access token](#customer-access-token).

<Callout type="info">
  The channel ID for the default Stencil storefront is `1`. Storefront tokens don't require you to pass in channel IDs if you want to make the request on behalf of all the stores channels IDs. To learn more about channels, see [the channels section of the multi-storefront overview](/docs/storefront/multi-storefront#channels). For more about using the GraphQL Storefront API on custom channels, consult the GraphQL Storefront API overview's [FAQ section on alternate channels](/docs/storefront/graphql#i-want-to-run-requests-in-the-context-of-another-channel).
</Callout>

<Tabs items={['Request', 'Response']}>
<Tab>

```http filename="Example request: Create a storefront API token" showLineNumbers copy
POST https://api.bigcommerce.com/stores/{{STORE_HASH}}/v3/storefront/api-token
x-auth-token: {{access_token}}
accept: application/json
content-type: application/json

{
  "channel_ids": [1, 2, 3],            // array of integers (must be a valid channel IDs on the store)
  "expires_at": 1602288000,   // when the token will expire, as an integer unix timestamp (in seconds)
  "allowed_cors_origins": [   // array of origins (up to 2 origins per token)
    "https://example.com"
  ]
}
```
</Tab>
<Tab>

```json filename="Example response: Create a storefront API token" showLineNumbers copy
{
  "token": "...eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NiJ9...",
  "meta": {
    // ...
  }
}
```
</Tab>
</Tabs>

#### Customer access tokens

A customer access token is unique to an individual user's account because it represents an authenticated storefront session for GraphQL requests. You can obtain and use a customer access token only for server-to-server requests. Therefore, you must use the customer access token with a storefront token or private token. A customer access token becomes invalid on all devices when you log out of a single device.

<Callout type="warning">
Do not use this token for browser-side or client-side requests.
</Callout>

##### Obtaining a customer access token

There are two options to obtain a customer access token.

1. Login mutation
2. Login with a JWT

###### Login mutation

Enter your user email and password to use the login mutation. When using the login mutation in a server-to-server context, the mutation will return a customer access token in response to login actions as part of the GraphQL body instead of a cookie header. From there, you can store the customer access token in the presentation layer's session management system and send it with future GraphQL requests. If the login mutation request is from a browser, we will not return the customer access token in the body, and will instead set a cookie.

<Callout type="info">
* Use the [Create a Token](/docs/rest-authentication/tokens#create-a-token) endpoint to generate the storefront token or private token needed to run the login mutation call.
* If you request a customer access token in wrong communication context, you will receive the following error:
    ***Customer access token was requested in the body, but it's only returned for server-to-server requests. For browser requests it's set as an httpOnly cookie instead.***

* If you still have issues creating a customer access token, we recommend clearing your cookies to resolve any loading issues.
</Callout>

<Tabs items={['Request', 'Response']}>
<Tab>
```graphql filename="Example login mutation: Create a customer access token" showLineNumbers copy
# Creates a customer access token
POST https://{{storeDomain}}/graphql
Authorization: Bearer {Storefront token}
accept: application/json
content-type: application/json

mutation Login($email: String!, $pass: String!) {
 login(email: $email, password: $pass) {
   result
   customer {
     entityId
     email
   }
   customerAccessToken {
     value
     expiresAt
   }
 }
}
```

```json filename="GraphQL variables" showLineNumbers copy
{
    "email": "user@email.com",
    "pass": "password"
}
```
</Tab>
<Tab>

```json filename="Example login mutation: Create a customer access token" showLineNumbers copy
{
    "data": {
        "login": {
            "result": "success",
            "customer": {
                "entityId": 21,
                "email": "user@email.com"
            },
            "customerAccessToken": {
                "value": "53ea9099d5484cdedddbf8f59a73bc284afefd7943c4dbe578db52435e0c0de7_1721406629",
                "expiresAt": "2024-07-19T16:30:29Z"
            }
        }
    }
}
```
</Tab>
</Tabs>


###### Login with a JWT

There are two options for logging in using a JWT.

1. Customer Login API

The Customer Login API enables third-party services to securely authenticate a logged-in customer by accepting a signed JWT from BigCommerce. This allows the third party to verify the customerâ€™s identity before granting access to sensitive information. For more details, see the [Customer Login API](/docs/start/authentication/customer-login) article.

2. `loginWithCustomerLoginJwt`

The `loginWithCustomerLoginJwt` mutation allows you to pass a customer JSON web token instead of the user's email and password. A 3rd party signs the JSON web token used. In this scenario, you will generate a JWT that contains key information in the payload for the login to be successful. You will use this JWT in the login mutation to receive a customer access token. For instructions on creating a JWT, see the [Customer Login API](/docs/start/authentication/customer-login) article for instructions.


<Tabs items={['Request', 'Response']}>
<Tab>

```graphql filename="Example JWT login mutation: Create a customer access token" showLineNumbers copy
# Creates a customer access token
POST https://{{storeDomain}}/graphql
Authorization: Bearer {Storefront token}
accept: application/json
content-type: application/json

mutation Login($jwt: String!) {
 loginWithCustomerLoginJwt(jwt: $jwt) {
   customer {
     entityId
     email
   }
   customerAccessToken {
     value
     expiresAt
   }
 }
}
```

```json filename="GraphQL variables" showLineNumbers copy
{"jwt": "your_jwt_token"}
```
</Tab>
<Tab>

```json filename="Example JWT login mutation: Create a customer access token" showLineNumbers copy
{
    "data": {
        "loginWithCustomerLoginJwt": {
            "customer": {
                "entityId": 22,
                "email": "user@email.com"
            },
            "customerAccessToken": {
                "value": "ee973d6566a7c691af4602f344d866ecaa45bdcbdf2075d29d5e70fd0716b7c5_1721657159",
                "expiresAt": "2024-07-22T14:05:59Z"
            }
        }
    }
}
```
</Tab>
</Tabs>


##### Using a Customer Access Token

You can assign the customer access token obtained using one of the mutations described above to the `X-Bc-Customer-Access-Token` header for future queries. You can use this token for a specific shopper session access until it is invalidated or if it expires due to time. The token is invalidated when you use the logout mutation with the `X-Bc-Customer-Access-Token` header.

<Tabs items={['Request', 'Response']}>
<Tab>

```graphql filename="Example customer query" showLineNumbers copy
POST https://{{storeDomain}}/graphql
Authorization: Bearer {Storefront token}
X-Bc-Customer-Access-Token: {Customer access token}
accept: application/json
content-type: application/json

query CustomerAttributes {
  customer {
    firstName
    lastName
    email
    entityId
    customerGroupId
    attributeCount
    attributes {
      shirtSize: attribute(entityId:123) {
        entityId
        value
      }
      favoriteColor: attribute(entityId:456) {
        entityId
        value
      }
    }
  }
}
```
</Tab>
<Tab>

```json filename="Example customer query" showLineNumbers copy
{
    "data": {
        "customer": {
            "firstName": "John",
            "lastName": "Doe",
            "email": "john.doe@example.com",
            "entityId": 21,
            "customerGroupId": 2,
            "attributeCount": 0,
            "attributes": {
                "shirtSize": {
                    "entityId": 123,
                    "value": "medium"
                },
                "favoriteColor": {
                    "entityId": 456,
                    "value": "blue"
                }
            }
        }
    }
}
```
</Tab>
</Tabs>


### Using auto-generated tokens on Stencil storefronts

On Stencil storefronts, you can access a token at render time and pass the token to client-side code using the `{{settings.storefront_api.token}}` Handlebars property. This auto-generated token has an expiry period of 24-48 hours and will rotate before expiration.

## Private tokens

Private tokens are designed for server-to-server integrations. They are always stateless (no session required) and provide better performance for server-to-server use cases.

### Private token characteristics

- **Server-to-server only:** The API rejects private token-authenticated requests that originate from web browsers
- **Always stateless:** No session or cookie validation required
- **Required for server-to-server:** Private tokens are required for all server-to-server integrations. Storefront tokens cannot be used statelessly in server-to-server contexts.

<Callout type="info">
Private tokens are the recommended choice for new server-to-server integrations that don't require customer impersonation. They provide better performance and are designed specifically for stateless server-to-server use cases.
</Callout>

### Create a private token

Use the [Create a private token](/docs/rest-authentication/tokens#create-a-private-token) REST endpoint to create private tokens. Add the [storefront API tokens creation scope](/docs/start/authentication/api-accounts#token-creation-scopes) to the [store-level or app-level API account](/docs/start/authentication/api-accounts) you use to generate tokens.

<Tabs items={['Request', 'Response']}>
<Tab>

```http filename="Example request: Create a private token" showLineNumbers copy
POST https://api.bigcommerce.com/stores/{{STORE_HASH}}/v3/storefront/api-token-private
x-auth-token: {{access_token}}
accept: application/json
content-type: application/json

{
  "channel_ids": [1, 2, 3],            // array of integers (must be a valid channel IDs on the store)
  "expires_at": 1602288000   // when the token will expire, as an integer unix timestamp (in seconds)
}
```
</Tab>
<Tab>

```json filename="Example response: Create a private token" showLineNumbers copy
{
  "token": "...eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NiJ9...",
  "meta": {
    // ...
  }
}
```
</Tab>
</Tabs>

### Private token security

Private tokens are sensitive and should **never** be exposed publicly. Treat them with the same care as other application secrets, such as API account access tokens. Store them securely on your server and never include them in client-side code or expose them in browser contexts.

If your token is compromised, you can use the [Revoke a token](/docs/rest-authentication/tokens#revoke-a-token) endpoint. Only use this in emergencies; do not revoke tokens unnecessarily. Instead, use a shorter expiration and allow them to expire naturally.

## Customer impersonation tokens

<Callout type="warning">
Because of the flexible use of the customer impersonation token, BigCommerce recommends using a more secure option like the [customer access token](#customer-access-tokens). Customer impersonation tokens allow you to access any customer by simply changing the `X-Bc-Customer-Id` value in the header for server-to-server communications. However, the customer access token is tied directly to a specific customer as part of the token payload providing a more secure experience. In addition, customer access tokens have the following added benefits:
* A customer access token is unique to an individual user's account.
* A customer access token allows users to act on different systems.
* A customer access token becomes invalid on all devices when you log out on a single device.
</Callout>

You can use customer impersonation tokens to authenticate requests to the GraphQL Storefront API in server-to-server and headless interactions. The API will reject any customer impersonation token-authenticated requests that originate from a web browser and are not proxied.

<Callout type="warning">
In the future, we will not support all customer features when using a customer impersonation token. More security-sensitive features will only work with the customer access token. For example, features like exposing a customer's Saved Payment Methods will only work with a customer access token.
</Callout>

Customer impersonation token-authenticated requests will be specific to the customer, including product pricing and availability, customer account details, and more.

It is not necessary to generate a new token for each customer ID. You may use a single token at any given time for your application and specify a distinct customer ID for each set of requests.

Using a customer impersonation token does not automatically sign a customer in. For that, use the [customer login mutation](#signing-customers-in) or the [Customer Login API](/docs/rest-authentication/customer-login).

### Create a customer impersonation token

Add the [Storefront API customer impersonation tokens creation scope](/docs/start/authentication/api-accounts#token-creation-scopes) to the [store-level or app-level API account](/docs/start/authentication/api-accounts) you use when you [Create a customer impersonation token](/docs/rest-authentication/tokens/customer-impersonation-token).

<Tabs items={['Request', 'Response']}>
<Tab>

```http filename="Example request: Create a customer impersonation token" showLineNumbers copy
POST https://api.bigcommerce.com/stores/{{STORE_HASH}}/v3/storefront/api-token-customer-impersonation
X-Auth-Token: {{access_token}}
Accept: application/json
Content-Type: application/json

{
  "channel_ids": [1, 2, 3], // array of integers (must be a valid channel IDs on the store)
  "expires_at": 1602288000 // when the token will expire, as an integer unix timestamp (in seconds)
}
```
</Tab>
<Tab>

```json filename="Example response: Create a customer impersonation token" showLineNumbers copy
{
  "data":
  {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
  },
  "meta": {}
}
```
</Tab>
</Tabs>

### Customer impersonation token security

Unlike storefront API tokens, customer impersonation tokens _are_ sensitive and should **never** be exposed publicly. Treat them with the same care as other application secrets, such as API account access tokens.

If your token is compromised, you can use the [Revoke a token](/docs/rest-authentication/tokens#revoke-a-token) endpoint. Only use this in emergencies; do not revoke tokens unnecessarily. Instead, use a shorter expiration and allow them to expire naturally.

## Signing customers in

<Callout type="info">
A customer can only sign in on one device. When you run the customer login mutation for a session on a new device, the customer is automatically signed out of the previous session.
</Callout>

If you're using the GraphQL Storefront API from a browser, for example, on top of your Stencil storefront, you can use the login mutation to sign in to a customer account with an email address and a password. This will set a session cookie in the browser, which will authenticate the customer account on future requests. You can also perform a login operation by passing the `guestCartEntityID` variable and assigning a cart to a customer.


This mutation is also useful for server-to-server or headless storefront applications that use a customer impersonation token. For example, you can use a sign in form to validate a customer's email address and password. When the mutation returns successfully, you can take the resulting customer ID and store it in a session to pass with the `X-Bc-Customer-Id` header.

As a security best practice, you should inject the email address and password using GraphQL query variables. This prevents the password from being exposed in the query itself. In the [GraphQL Storefront playground](/graphql-storefront/playground), you can set variables for requests.

![GraphQL Storefront playground query variables](https://storage.googleapis.com/bigcommerce-production-dev-center/images/Playground%20Login%20Mutation.png "GraphQL Storefront playground query variables")

<Callout type="warning">
  In the customer login mutation, the `result` field is deprecated. Instead, request customer object information.
</Callout>

<Tabs items={['HTTP', 'Mutation', 'Variables', 'Response']}>
  <Tab>

    ```http filename="Login mutation request" copy
      POST https://your_store.example.com/graphql
      Accept: application/json
      Content-Type: application/json
      Authorization: Bearer {token}
    ```

  </Tab>
  <Tab>

    ```graphql filename="Login mutation" showLineNumbers copy
      mutation Login($email: String!, $pass: String!) {
        login(email: $email, password: $pass) {
          customer {
            entityId
            firstName
            email
            taxExemptCategory
            storeCredit {
              currencyCode
              value
            }
            formFields {
              entityId
              name
            }
          }
        }
      }
    ```

  </Tab>
  <Tab>

    ```json filename="Login mutation variables" showLineNumbers copy
      {
        "email": "jane.doe@example.com",
        "pass": "xxxxxxxxxxxxxxxxx"
      }
    ```

  </Tab>
  <Tab>

    ```json filename="Login mutation response" showLineNumbers copy
      {
        "data": {
          "login": {
            "customer": {
              "entityId": 378,
              "firstName": "Jane",
              "email": "jane.doe@example.com",
              "customerGroupId": 7,
              "taxExemptCategory": "",
              "storeCredit": [
                {
                  "currencyCode": "USD",
                  "value": 0
                }
              ],
              "formFields": [
                {
                  "entityId": 26,
                  "name": "Birthday"
                }
              ]
            }
          }
        }
      }
    ```

  </Tab>
</Tabs>

## Signing customers out

You can use the logout mutation to sign out of a customer account. If you're using a vanilla storefront token, future requests in that shopper's session will be from the perspective of an anonymous shopper.

```graphql filename="Example query: logout mutation" showLineNumbers copy
mutation Logout {
  logout {
    result
  }
}
```
<Callout type="info">
If you're signed out, the system reverts to a "guest" version of the cart, allowing a guest shopper to view their cart once logged out.
</Callout>

## Further reading

* [GraphQL Storefront API overview](/docs/storefront/graphql)
* [GraphQL Storefront API reference](/graphql-storefront/reference)
* [GraphQL Storefront playground](/graphql-storefront/playground)
* [Authentication and example requests: GraphQL Storefront API](/docs/start/authentication)
* [Guide to API accounts: OAuth scopes](/docs/start/authentication/api-accounts#token-creation-scopes)
* [Multi-storefront overview](/docs/storefront/multi-storefront)
* [CORS (Mozilla)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)

### Endpoints

* [Create a storefront token](/docs/rest-authentication/tokens#create-a-token)
* [Create a private token](/docs/rest-authentication/tokens#create-a-private-token)
* [Create a customer impersonation token](/docs/rest-authentication/tokens/customer-impersonation-token)
* [Revoke a token](/docs/rest-authentication/tokens#revoke-a-token)
* [Customer Login API](/docs/rest-authentication/customer-login)
