# Authenticating requests to the GraphQL Storefront API

GraphQL Storefront API requests are authenticated with JWT bearer tokens sent using the HTTP `Authorization` header.


```shell filename="Example Authorization header using cURL" showLineNumbers copy
curl 'https://{bigcommerce_storefront_domain}.com/graphql'\
  # ...
  -H 'authorization: Bearer {token}'\
  # ...
```

## Creating a token

Use the [Create a storefront token](/docs/rest-authentication/tokens#create-a-token) REST endpoint to request JWT bearer tokens that authenticate requests to the GraphQL Storefront API. Add a [token creation scope](/docs/start/authentication/api-accounts#token-creation-scopes) to the [store-level or app-level API account](/docs/start/authentication/api-accounts) you use to generate tokens.

This type of token is the most appropriate for use directly within web browsers. If you're creating a token for an application that will make server-to-server requests to the GraphQL Storefront API, a [customer impersonation token](#customer-impersonation-tokens) may be more appropriate for your use case. This special token is not necessary if you only wish to query information from an anonymous shopper's perspective.

For security reasons, GraphQL Storefront API tokens are scoped to particular [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) origins, so you must supply the origin(s) on which you intend to use the token in order for requests from browsers to work correctly. If you do not supply any CORS origins for your token, the API will reject requests originating from web browsers, although you can still use it in other contexts.

<Tabs items={['Request', 'Response']}>
<Tab>

```http filename="Example request: Create a GraphQL Storefront API token" showLineNumbers copy
POST https://api.bigcommerce.com/stores/{{STORE_HASH}}/v3/storefront/api-token
x-auth-token: {{access_token}}
accept: application/json
content-type: application/json

{
  "channel_id": 1,            // integer (must be a valid channel ID on the store)
  "expires_at": 1602288000,   // when the token will expire, as an integer unix timestamp (in seconds)
  "allowed_cors_origins": [   // array of origins (up to 2 origins per token are allowed)
    "https://example.com"
  ]
}
```
</Tab>
<Tab>

```json filename="Example response: Create a GraphQL Storefront API token" showLineNumbers copy
{
  "token":"...eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzI1NiJ9...",
  "meta": {
    // ...
  }
}
```
</Tab>
</Tabs>

<Callout type="info">
  * The `allowed_cors_origins` array currently accepts up to two origins. You will need multiple tokens if you have more origins.
  * The `channel_id` for the default Stencil storefront is `1`. To learn more about channels, see [the channels section of the Multi-Storefront Overview](/docs/storefront/multi-storefront#channels). For more about using the GraphQL Storefront API on custom channels, consult this article's [FAQ section on alternate channels](/docs/storefront/graphql#i-want-to-run-requests-in-the-context-of-another-channel).
</Callout>

<Callout type="info">
  * Generally speaking, this type of GraphQL Storefront API token is not considered sensitive, and it is safe to expose in web browsers, for example, in HTML documents. This token can only expose information that an individual shopper is already privy to when browsing a storefront or allow them to perform actions that shoppers can perform (e.g. creating a shopper cart).
  * It is **possible** to create a long-lived token that does not expire, which is appropriate if you wish to create a token once and store it in an application environment.
  * In the interest of a better security posture, it is **recommended** to create shorter-lived tokens and rotate them periodically by calling this API to generate a new one before the old one expires.
</Callout>

## Using auto-generated tokens in Stencil themes

Client code in BigCommerce Stencil themes can be passed a token at render time with the `{{settings.storefront_api.token}}` Handlebars property, making it unnecessary to generate a token using the Admin API before using the Storefront API.

This auto-generated token has an expiry period of 24-48 hours and will periodically rotate before expiration.

## Customer impersonation tokens

You can use Customer Impersonation Tokens to authenticate requests to the GraphQL Storefront API in server-to-server and headless interactions. Add the [Storefront API Customer Impersonation Tokens scope](/docs/start/authentication/api-accounts#token-creation-scopes) to the [store-level or app-level API account](/docs/start/authentication/api-accounts) you use when you [Create a customer impersonation token](/docs/rest-authentication/tokens/customer-impersonation-token). 

<Tabs items={['Request', 'Response']}>
<Tab>

```http filename="Example request: Create a customer impersonation token" showLineNumbers copy
POST https://api.bigcommerce.com/stores/{{STORE_HASH}}/v3/storefront/api-token-customer-impersonation
x-auth-token: {{access_token}}
accept: application/json
content-type: application/json

{
  "channel_id": 1, // integer (must be a valid channel ID on the store)
  "expires_at": 1602288000 // when the token will expire, as an integer unix timestamp (in seconds)
}
```
</Tab>
<Tab>

```json filename="Example response: Create a customer impersonation token" showLineNumbers copy
{
  "data":
  {
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
  }
  "meta": {}
}
```
</Tab>
</Tabs>

Customer impersonation token-authenticated requests made to the GraphQL Storefront API may query store information from the perspective of ANY customer by specifying the customer ID using the `x-bc-customer-id` header sent with the GraphQL `POST` request. Customer-specific data such as product pricing & availability, customer account details, and other parameters will change to reflect the specified customer's data.

Unlike typical GraphQL Storefront API tokens, Customer impersonation tokens _are_ sensitive and should, therefore **never** be exposed publicly, for example, to JavaScript or HTML. You should not use these tokens for front-end requests. They should be treated with the same care as other application secrets, just as you might treat an OAuth access token for BigCommerce's REST APIs. Requests using these tokens originating from a web browser will be rejected.

It is not necessary to generate a new token for each customer ID. You may use a single token at any given time for your application, and specify the customer ID for each request via request headers.

Consider this sample request using a Customer Impersonation token to run a request in the context of customer ID `123`.

```shell filename="Example request: Query as customer 123" showLineNumbers copy
curl 'https://your_store.example.com/graphql' -H 'authorization: Bearer TOKEN_GOES_HERE' -H 'x-bc-customer-id: 123' --data-binary '{"query":"query CustomerInformation {\n  customer {\n    firstName\n    lastName\n    email\n  }\n}"}'
```

<Callout type="info">
  * If your token were to become compromised and you wish to sever the Storefront API connection for your token, you can use the [Revoke a token](/docs/rest-authentication/tokens#revoke-a-token) endpoint. Only use this in emergencies, and do not revoke tokens unnecessarily. Instead, use a shorter expiration and allow them to expire naturally.
</Callout>

## Signing customers in

If you're using the GraphQL Storefront API from a browser, for example, on top of your Stencil storefront, you can use the login mutation to sign in to a customer account with an email address and a password. This will set a session cookie in the browser, which will authenticate the customer account on future requests.

<Callout type="info">
A customer can only sign in to their account on one device. When running the customer login mutation for a session on a new device, a customer is automatically signed out.
</Callout>

```graphql filename="Example query: login mutation" showLineNumbers copy
mutation Login($email: String!, $pass: String!) {
  login(email: $email, password: $pass) {
    result
    customer {
      entityId
      firstName
      lastName
      email
    }
  }
}
```

This mutation is also useful for server-to-server or headless storefront applications using a Customer Impersonation Token. For example, this interface can validate a customer's email address + password to power a login form. When the credentials are correct, and the mutation returns successfully, you can take the resulting customer ID and store it in a session to use in the `x-bc-customer-id` header in future requests for that shopper.

As a security best practice, you should inject the email address & password using GraphQL query variables. This prevents the password from being exposed in the query itself. In the [GraphQL Storefront playground](/graphql-storefront/playground), you can set the variables for the request.

![GraphQL Storefront playground query variables](https://storage.googleapis.com/bigcommerce-production-dev-center/images/Playground%20Login%20Mutation.png "GraphQL Storefront playground query variables")

You can use a logout mutation to sign out of a customer account:

```graphql filename="Example query: logout mutation" showLineNumbers copy
mutation Logout {
  logout {
    result
  }
}
```

This will clear the session cookie, which has the effect of logging out the shopper, and future GraphQL requests will be from the perspective of an anonymous shopper.
