# GraphQL Complexity Limiter

This document explains how the **per-IP inflight GraphQL complexity limiter** behaves in Storefront GraphQL and how to interpret limiter headers.

---

## Why your query can be limited

The limiter protects Storefront GraphQL infrastructure from bursts of expensive concurrent traffic from a single source.

At runtime, each request has a calculated GraphQL complexity. The service tracks in-flight complexity per IP
and rejects requests when accepting a new one would exceed the configured per-IP in-flight threshold.
This prevents one source from over-consuming shared compute and helps keep latency stable for everyone.

The limiter is applied only for Storefront GraphQL API origin requests.

---

## Client profiles and recommendations

### 1) Stencil (pure frontend)

When using Stencil, you are a frontend client. Optimize page-load behavior:

- Avoid firing many GraphQL queries at once on initial page load.
- Prefer batching/fewer round-trips where possible.
- Cache repeated reads aggressively.

### 2) Catalyst (headless)

Catalyst can act like frontend traffic or backend traffic depending on your architecture.

- Keep GraphQL calls minimal.
- Cache reusable results.
- Control concurrency on server-render paths.

### 3) Server-to-server

You usually have the most control.

- Use a trusted proxy/load balancer configuration so the effective client IP is propagated correctly.
- Add edge/application caching.
- Avoid fan-out bursts from one egress IP.

---

## Header reference

### `X-BC-IP-Rate-Limit-Requests-Quota`

Current configured per-IP in-flight complexity threshold used by limiter evaluation for this request.

### `X-BC-IP-Rate-Limit-Requests-Quota-Left`

Remaining per-IP in-flight complexity before crossing threshold, based on current in-flight counters.

---

## All response header combinations and examples

> Note: examples show realistic values; exact numbers vary per environment and traffic state.

### Case A: Per-IP limiter evaluated, request allowed

- Typical status: `200` (or any non-429 business status)
- Headers:

```http
X-BC-IP-Rate-Limit-Requests-Quota: 50000
X-BC-IP-Rate-Limit-Requests-Quota-Left: 35000
```

Meaning: request passed and the limiter reports current quota and remaining headroom.

### Case B: Per-IP limiter evaluated, request rejected

- Status: `429 Too Many Requests`
- Headers:

```http
X-BC-IP-Rate-Limit-Requests-Quota: 50000
X-BC-IP-Rate-Limit-Requests-Quota-Left: 750
```

Meaning: request was rejected because this IP exceeded per-IP in-flight complexity threshold.

---

## Quota value is not a public contract

The `X-BC-IP-Rate-Limit-Requests-Quota` header reflects the **current configured per-IP in-flight complexity threshold**.

- It can be changed without notice.
- It should **not** be treated as a fixed, publicly advertised SLA number.

In other words: do not hardcode logic around a specific value. Always read and react to headers dynamically.

## Operational guidance

- Treat `429` as retryable with backoff/jitter.
- Reduce burst concurrency per IP.
- Cache read-heavy queries.
- Avoid redundant page-load calls.
- Inspect `X-BC-IP-Rate-Limit-Requests-Quota` for the configured quota value (the maximum allowed request weight for the current window).
- Inspect `X-BC-IP-Rate-Limit-Requests-Quota-Left` to understand how much quota remains and whether you are approaching the threshold.
- Calculate the current requestâ€™s query complexity by subtracting `X-BC-IP-Rate-Limit-Requests-Quota-Left` from `X-BC-IP-Rate-Limit-Requests-Quota`.
  The difference represents how much of the quota has been consumed in the current window,
  which reflects the effective complexity of the executed query.
